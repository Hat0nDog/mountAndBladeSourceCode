// Decompiled with JetBrains decompiler
// Type: TaleWorlds.MountAndBlade.CoreManaged
// Assembly: TaleWorlds.MountAndBlade, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3C0E3F42-756F-4407-B817-06BA412A78B0
// Assembly location: E:\SteamLibrary\steamapps\common\Mount & Blade II Bannerlord\bin\Win64_Shipping_Client\TaleWorlds.MountAndBlade.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using TaleWorlds.DotNet;
using TaleWorlds.Library;

namespace TaleWorlds.MountAndBlade
{
  public class CoreManaged : IManagedComponent
  {
    private static CoreManaged _instance;
    private static ICallbackManager _callbackManager;
    private static Dictionary<int, IntPtr> _engineApiPointers = new Dictionary<int, IntPtr>();
    private static Delegate _passManagedCoreCallbackMethodPointersMono = (Delegate) null;

    public string ManagedCallbacksDll => ManagedDllFolder.Name + "TaleWorlds.MountAndBlade.AutoGenerated.dll";

    public CoreManaged() => CoreManaged._instance = this;

    [MBCallback]
    public static void Start() => Managed.Start((IEnumerable<IManagedComponent>) new IManagedComponent[0]);

    [MBCallback]
    internal static void CheckSharedStrctureSizes()
    {
    }

    void IManagedComponent.OnStart()
    {
      Debug.DebugManager = (IDebugManager) new MBDebugManager();
      FaceGen.CreateInstance();
      Dictionary<string, Type> dictionary1 = new Dictionary<string, Type>();
      foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
      {
        Dictionary<string, Type> dictionary2 = this.CollectModuleAssemblyTypes(assembly);
        dictionary1 = dictionary1.Union<KeyValuePair<string, Type>>((IEnumerable<KeyValuePair<string, Type>>) dictionary2).ToDictionary<KeyValuePair<string, Type>, string, Type>((Func<KeyValuePair<string, Type>, string>) (k => k.Key), (Func<KeyValuePair<string, Type>, Type>) (v => v.Value));
      }
      Managed.InitializeTypes(dictionary1);
    }

    private Dictionary<string, Type> CollectModuleAssemblyTypes(
      Assembly moduleAssembly)
    {
      Dictionary<string, Type> dictionary = new Dictionary<string, Type>();
      try
      {
        foreach (Type type in moduleAssembly.GetTypes())
        {
          if (typeof (ManagedObject).IsAssignableFrom(type) || typeof (DotNetObject).IsAssignableFrom(type))
            dictionary.Add(type.Name, type);
        }
      }
      catch (Exception ex)
      {
        dictionary.Clear();
      }
      return dictionary;
    }

    [MBCallback]
    internal static void Initialize() => CoreManaged._instance.OnInitialize();

    private void OnInitialize()
    {
      Type[] types = AssemblyLoader.LoadFrom(this.ManagedCallbacksDll).GetTypes();
      Type type1 = (Type) null;
      foreach (Type type2 in types)
      {
        if (((IEnumerable<Type>) type2.GetInterfaces()).Contains<Type>(typeof (ICallbackManager)))
        {
          type1 = type2;
          break;
        }
      }
      CoreManaged._callbackManager = type1.GetConstructor(new Type[0]).Invoke(new object[0]) as ICallbackManager;
      CoreManaged._callbackManager.Initialize();
      Delegate[] delegates = CoreManaged._callbackManager.GetDelegates();
      for (int index = 0; index < delegates.Length; ++index)
      {
        try
        {
          CoreManaged.PassManagedCoreCallbackMethodPointers(delegates[index]);
        }
        catch (Exception ex)
        {
          CoreManaged.PassManagedCoreCallbackMethodPointers((Delegate) null);
          // ISSUE: variable of a boxed type
          __Boxed<int> local = (ValueType) index;
          Console.WriteLine(ex.ToString() + " " + (object) local);
        }
      }
      MBAPI.SetObjects(CoreManaged._callbackManager.GetScriptingInterfaceObjects());
      Module.CreateModule();
    }

    void IManagedComponent.OnCustomCallbackMethodPassed(
      string name,
      Delegate method)
    {
      if (!(name == "MBCore"))
        return;
      CoreManaged._passManagedCoreCallbackMethodPointersMono = method;
      this.OnInitialize();
    }

    [MBCallback]
    internal static void Finalize()
    {
      Module.FinalizeCurrentModule();
      Common.MemoryCleanup();
    }

    void IManagedComponent.OnApplicationTick(float dt)
    {
      MBGarbageDeleteQueue.Tick();
      Module.CurrentModule.OnApplicationTick(dt);
    }

    [MBCallback]
    internal static void CheckSharedStructureSizes() => CoreManaged._callbackManager.CheckSharedStructureSizes();

    [MBCallback]
    internal static void EngineApiMethodInterfaceInitializer(int id, IntPtr pointer) => CoreManaged._engineApiPointers.Add(id, pointer);

    [MBCallback]
    internal static void FillEngineApiPointers()
    {
      foreach (KeyValuePair<int, IntPtr> engineApiPointer in CoreManaged._engineApiPointers)
      {
        try
        {
          CoreManaged._callbackManager.SetFunctionPointer(engineApiPointer.Key, engineApiPointer.Value);
        }
        catch (Exception ex)
        {
          Console.WriteLine("error: " + (object) engineApiPointer.Key + " " + (object) ex);
        }
      }
    }

    private static void PassManagedCoreCallbackMethodPointers(Delegate methodDelegate)
    {
      if ((object) CoreManaged._passManagedCoreCallbackMethodPointersMono == null)
        return;
      CoreManaged._passManagedCoreCallbackMethodPointersMono.DynamicInvoke((object) methodDelegate);
    }
  }
}
