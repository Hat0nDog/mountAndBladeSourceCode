// Decompiled with JetBrains decompiler
// Type: TaleWorlds.DotNet.Managed
// Assembly: TaleWorlds.DotNet, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 207BAA99-20DA-4442-9622-4DB0CDEF3C0E
// Assembly location: E:\SteamLibrary\steamapps\common\Mount & Blade II Bannerlord\bin\Win64_Shipping_Client\TaleWorlds.DotNet.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using TaleWorlds.Library;

namespace TaleWorlds.DotNet
{
  public static class Managed
  {
    private static List<IManagedComponent> _components;
    private static ICallbackManager _callbackManager;
    internal static string ReturnValueFromEngine = "";
    private static ManagedInitializeMethod _initializer;
    private static Dictionary<string, Type> _moduleTypes;
    private static Dictionary<int, IntPtr> _engineApiPointers = new Dictionary<int, IntPtr>();
    private static Delegate PassManagedInitializeMethodPointerMono = (Delegate) null;
    private static Delegate PassManagedEngineCallbackMethodPointersMono = (Delegate) null;

    internal static bool Closing { get; private set; }

    internal static Dictionary<string, Type> ModuleTypes => Managed._moduleTypes;

    public static bool IsDotNet { get; private set; }

    public static uint TelemetryLevelMask { get; private set; }

    static Managed()
    {
      Managed._components = new List<IManagedComponent>();
      Managed.Closing = false;
      Managed.IsDotNet = false;
      Managed.TelemetryLevelMask = 4096U;
    }

    public static void SetAsDotNet() => Managed.IsDotNet = true;

    public static string ManagedCallbacksDll => ManagedDllFolder.Name + "TaleWorlds.DotNet.AutoGenerated.dll";

    [LibraryCallback]
    internal static void SetLogsFolder(string logFolder)
    {
    }

    [LibraryCallback]
    public static string GetStackTraceStr(int skipCount = 0)
    {
      string str = new StackTrace(skipCount, true).ToString().Replace("\r", "").Replace("   ", "");
      return str.Length >= 16 ? str : "";
    }

    [LibraryCallback]
    public static string GetStackTraceRaw(int skipCount = 0) => Managed.GetStackTraceRaw(new StackTrace(0, false), skipCount);

    public static string GetStackTraceRaw(StackTrace stack, int skipCount = 0)
    {
      MBStringBuilder mbStringBuilder = new MBStringBuilder();
      mbStringBuilder.Initialize(callerMemberName: nameof (GetStackTraceRaw));
      for (int index = 0; index < stack.FrameCount; ++index)
      {
        if (index >= skipCount)
        {
          string str = "unknown_module.dll";
          try
          {
            StackFrame frame = stack.GetFrame(index);
            MethodBase method = frame.GetMethod();
            str = method.Module.Assembly.Location;
            int ilOffset = frame.GetILOffset();
            int metadataToken = method.MetadataToken;
            mbStringBuilder.AppendLine<string>(str + "@" + (object) metadataToken + "@" + (object) ilOffset);
          }
          catch
          {
            mbStringBuilder.AppendLine<string>(str + "@-1@-1");
          }
        }
      }
      return mbStringBuilder.ToStringAndRelease();
    }

    [LibraryCallback]
    public static string GetModuleList()
    {
      Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
      string str = "";
      foreach (Assembly assembly in assemblies)
      {
        try
        {
          str += assembly.Location;
          str += "\n";
        }
        catch
        {
        }
      }
      return str;
    }

    [LibraryCallback]
    public static void GetVersionInts(ref int major, ref int minor, ref int revision)
    {
      ApplicationVersion applicationVersion = ApplicationVersion.FromParametersFile(ApplicationVersionGameType.Singleplayer);
      major = applicationVersion.Major;
      minor = applicationVersion.Minor;
      revision = applicationVersion.Revision;
    }

    [LibraryCallback]
    internal static DotNetObject CreateCustomParameterStringArray(int length) => (DotNetObject) new CustomParameter<string[]>(new string[length]);

    internal static DotNetObject AddCustomParameter<T>(T parameterData) where T : class => (DotNetObject) new CustomParameter<T>(parameterData);

    [LibraryCallback]
    internal static void GarbageCollect()
    {
      GC.Collect();
      GC.WaitForPendingFinalizers();
    }

    [LibraryCallback]
    internal static void SetStringArrayValueAtIndex(string[] array, int index, string value) => array[index] = value;

    [LibraryCallback]
    internal static string GetStringArrayValueAtIndex(string[] array, int index) => array[index];

    internal static void PassInitializationMethodPointersForMono(IntPtr a, IntPtr b)
    {
      Managed.PassManagedInitializeMethodPointerMono = Marshal.GetDelegateForFunctionPointer(a, typeof (Managed.PassManagedInitializeMethodPointerDelegate));
      Managed.PassManagedEngineCallbackMethodPointersMono = Marshal.GetDelegateForFunctionPointer(b, typeof (Managed.PassManagedCallbackMethodPointersDelegate));
    }

    public static void PassInitializationMethodPointersForDotNet(Delegate a, Delegate b)
    {
      Managed.PassManagedInitializeMethodPointerMono = a;
      Managed.PassManagedEngineCallbackMethodPointersMono = b;
    }

    public static void Start(IEnumerable<IManagedComponent> components)
    {
      Managed._components.AddRange(components);
      Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
      AppDomain.CurrentDomain.AppendPrivatePath(ManagedDllFolder.Name);
      AssemblyLoader.Initialize();
      Managed._initializer = new ManagedInitializeMethod(Managed.Initialize);
      Managed.PassManagedInitializeMethodPointer((Delegate) Managed._initializer);
      for (int index = 0; index < Managed._components.Count; ++index)
        Managed._components[index].OnStart();
    }

    [MonoPInvokeCallback(typeof (ManagedInitializeMethod))]
    private static void Initialize()
    {
      Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
      Type[] types = AssemblyLoader.LoadFrom(Managed.ManagedCallbacksDll).GetTypes();
      Type type1 = (Type) null;
      foreach (Type type2 in types)
      {
        if (((IEnumerable<Type>) type2.GetInterfaces()).Contains<Type>(typeof (ICallbackManager)))
        {
          type1 = type2;
          break;
        }
      }
      Managed._callbackManager = type1.GetConstructor(new Type[0]).Invoke(new object[0]) as ICallbackManager;
      Managed._callbackManager.Initialize();
      Delegate[] delegates = Managed._callbackManager.GetDelegates();
      for (int index = 0; index < delegates.Length; ++index)
      {
        try
        {
          Managed.PassManagedEngineCallbackMethodPointers(delegates[index]);
        }
        catch (Exception ex)
        {
          Managed.PassManagedEngineCallbackMethodPointers((Delegate) null);
          // ISSUE: variable of a boxed type
          __Boxed<int> local = (ValueType) index;
          Console.WriteLine(ex.ToString() + " " + (object) local);
        }
      }
      LibraryApplicationInterface.SetObjects(Managed._callbackManager.GetScriptingInterfaceObjects());
    }

    [LibraryCallback]
    internal static void CheckSharedStructureSizes() => Managed._callbackManager.CheckSharedStructureSizes();

    [LibraryCallback]
    internal static void SetClosing() => Managed.Closing = true;

    [LibraryCallback]
    internal static void PreFinalize()
    {
      Managed.Closing = true;
      Managed._moduleTypes = (Dictionary<string, Type>) null;
      ManagedObjectOwner.PreFinalizeManagedObjects();
      Common.MemoryCleanup();
    }

    [LibraryCallback]
    internal static void OnFinalize()
    {
      ManagedObject.FinalizeManagedObjects();
      Common.MemoryCleanup();
      ManagedObjectOwner.LogFinalize();
    }

    [LibraryCallback]
    internal static void ApplicationTick(float dt)
    {
      ManagedObject.HandleManagedObjects();
      DotNetObject.HandleDotNetObjects();
      NativeObject.HandleNativeObjects();
      ManagedObjectOwner.GarbageCollect();
      Managed.TelemetryLevelMask = LibraryApplicationInterface.ITelemetry.GetTelemetryLevelMask();
      for (int index = 0; index < Managed._components.Count; ++index)
        Managed._components[index].OnApplicationTick(dt);
    }

    [LibraryCallback]
    internal static bool CheckClassNameIsValid(string className) => Managed._moduleTypes.ContainsKey(className);

    [LibraryCallback]
    internal static int GetStringArrayLength(string[] array) => array.Length;

    [LibraryCallback]
    internal static string[] GetClassFields(
      string className,
      bool recursive,
      bool includeInternal,
      bool includeProtected,
      bool includePrivate)
    {
      List<string> stringList = new List<string>();
      Type type;
      if (Managed._moduleTypes.TryGetValue(className, out type))
      {
        FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        for (int index = 0; index < fields.Length; ++index)
        {
          FieldInfo fieldInfo = fields[index];
          if (((((false ? 1 : (fieldInfo.IsPublic ? 1 : 0)) != 0 ? 1 : (!includePrivate ? 0 : (fieldInfo.IsPrivate ? 1 : 0))) != 0 ? 1 : (!includeProtected ? 0 : (fieldInfo.IsFamily ? 1 : 0))) != 0 ? 1 : (!includeInternal ? 0 : (fieldInfo.IsAssembly ? 1 : 0))) != 0)
            stringList.Add(fields[index].Name);
        }
      }
      return stringList.ToArray();
    }

    [LibraryCallback]
    internal static ManagedObject CreateObjectClassInstanceWithPointer(
      string className,
      IntPtr pointer)
    {
      ConstructorInfo constructor = Managed._moduleTypes[className].GetConstructor(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, (Binder) null, new Type[1]
      {
        typeof (IntPtr)
      }, (ParameterModifier[]) null);
      if (constructor != (ConstructorInfo) null)
      {
        object obj = constructor.Invoke(new object[1]
        {
          (object) pointer
        });
        if (obj != null)
          return obj as ManagedObject;
      }
      return (ManagedObject) null;
    }

    internal static string GetClassNamesAux(Type type)
    {
      string str = "";
      foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
      {
        if (!assembly.GlobalAssemblyCache)
        {
          try
          {
            string[] strArray = Array.ConvertAll<Type, string>(Array.FindAll<Type>(assembly.GetTypes(), (Predicate<Type>) (t => (t.Equals(type) || t.IsSubclassOf(type)) && !t.IsAbstract)), (Converter<Type, string>) (t => t.Name));
            if (strArray.Length != 0)
            {
              if (str != "")
                str += " ";
              str += string.Join(" ", strArray);
            }
          }
          catch (ReflectionTypeLoadException ex)
          {
            TaleWorlds.Library.Debug.Print(ex.Message + " " + (object) ex.GetType());
            foreach (object obj in (IEnumerable) ex.Data.Values)
              TaleWorlds.Library.Debug.Print(obj.ToString());
          }
        }
      }
      return str;
    }

    [LibraryCallback]
    internal static ManagedObject CreateObjectClassInstanceWithInteger(
      string className,
      int value)
    {
      ConstructorInfo constructor = Managed._moduleTypes[className].GetConstructor(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, (Binder) null, new Type[1]
      {
        typeof (int)
      }, (ParameterModifier[]) null);
      if (constructor != (ConstructorInfo) null)
      {
        object obj = constructor.Invoke(new object[1]
        {
          (object) value
        });
        if (obj != null)
          return obj as ManagedObject;
      }
      return (ManagedObject) null;
    }

    [LibraryCallback]
    internal static void SetCurrentStringReturnValue(IntPtr pointer) => Managed.ReturnValueFromEngine = Marshal.PtrToStringAnsi(pointer);

    [LibraryCallback]
    internal static void SetCurrentStringReturnValueAsUnicode(IntPtr pointer)
    {
      Managed.ReturnValueFromEngine = Marshal.PtrToStringAnsi(pointer);
      Managed.ReturnValueFromEngine = Encoding.Unicode.GetString(Encoding.Convert(Encoding.UTF8, Encoding.Unicode, Encoding.Default.GetBytes(Managed.ReturnValueFromEngine)));
    }

    [LibraryCallback]
    internal static string GetObjectClassName(string className)
    {
      Type type;
      return Managed._moduleTypes.TryGetValue(className, out type) ? type.Name : "unknown";
    }

    [LibraryCallback]
    internal static void EngineApiMethodInterfaceInitializer(int id, IntPtr pointer) => Managed._engineApiPointers.Add(id, pointer);

    [LibraryCallback]
    internal static void FillEngineApiPointers()
    {
      foreach (KeyValuePair<int, IntPtr> engineApiPointer in Managed._engineApiPointers)
      {
        try
        {
          Managed._callbackManager.SetFunctionPointer(engineApiPointer.Key, engineApiPointer.Value);
        }
        catch (Exception ex)
        {
          Console.WriteLine("error: " + (object) engineApiPointer.Key + " " + (object) ex);
        }
      }
    }

    [LibraryCallback]
    internal static long GetMemoryUsage() => GC.GetTotalMemory(false);

    [LibraryCallback]
    internal static void PassCustomCallbackMethodPointers(string name, IntPtr initalizer)
    {
      Delegate forFunctionPointer = Marshal.GetDelegateForFunctionPointer(initalizer, typeof (Managed.InitializerDelegate));
      for (int index = 0; index < Managed._components.Count; ++index)
        Managed._components[index].OnCustomCallbackMethodPassed(name, forFunctionPointer);
    }

    [LibraryCallback]
    internal static string CallCommandlineFunction(string functionName, string arguments) => CommandLineFunctionality.CallFunction(functionName, arguments, out bool _);

    public static void InitializeTypes(Dictionary<string, Type> types) => Managed._moduleTypes = types;

    public static void AddTypes(Dictionary<string, Type> types) => Managed._moduleTypes = Managed._moduleTypes.Union<KeyValuePair<string, Type>>((IEnumerable<KeyValuePair<string, Type>>) types).ToDictionary<KeyValuePair<string, Type>, string, Type>((Func<KeyValuePair<string, Type>, string>) (k => k.Key), (Func<KeyValuePair<string, Type>, Type>) (v => v.Value));

    private static void PassManagedInitializeMethodPointer(Delegate initalizer)
    {
      if ((object) Managed.PassManagedInitializeMethodPointerMono == null)
        return;
      Managed.PassManagedInitializeMethodPointerMono.DynamicInvoke((object) initalizer);
    }

    private static void PassManagedEngineCallbackMethodPointers(Delegate methodDelegate)
    {
      if ((object) Managed.PassManagedEngineCallbackMethodPointersMono == null)
        return;
      Managed.PassManagedEngineCallbackMethodPointersMono.DynamicInvoke((object) methodDelegate);
    }

    [LibraryCallback]
    internal static void LoadManagedComponent(string assemblyName, string managedInterface)
    {
      IManagedComponent instance = (IManagedComponent) Activator.CreateInstance(AssemblyLoader.LoadFrom(ManagedDllFolder.Name + assemblyName + ".dll").GetType(managedInterface));
      Managed._components.Add(instance);
      instance.OnStart();
    }

    internal static FieldInfo GetFieldOfClass(string className, string fieldName)
    {
      Type type;
      if (Managed._moduleTypes.TryGetValue(className, out type))
      {
        foreach (FieldInfo field in type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic))
        {
          if (field.Name == fieldName)
            return field;
        }
      }
      return (FieldInfo) null;
    }

    [LibraryCallback]
    internal static bool IsClassFieldExists(string className, string fieldName) => Managed.GetFieldOfClass(className, fieldName) != (FieldInfo) null;

    [LibraryCallback]
    internal static bool IsFieldFixedPoint(string className, string fieldName)
    {
      Type fieldType = Managed.GetFieldOfClass(className, fieldName).FieldType;
      return fieldType == typeof (byte) || fieldType == typeof (sbyte) || (fieldType == typeof (short) || fieldType == typeof (ushort)) || (fieldType == typeof (int) || fieldType == typeof (uint) || fieldType == typeof (long)) || fieldType == typeof (ulong);
    }

    [LibraryCallback]
    internal static bool IsFieldUnsigned(string className, string fieldName)
    {
      Type fieldType = Managed.GetFieldOfClass(className, fieldName).FieldType;
      return fieldType == typeof (byte) || fieldType == typeof (ushort) || fieldType == typeof (uint) || fieldType == typeof (ulong);
    }

    [LibraryCallback]
    internal static bool IsFieldClass(string className, string fieldName)
    {
      Type fieldType = Managed.GetFieldOfClass(className, fieldName).FieldType;
      if (fieldType.IsClass)
        return true;
      return fieldType.IsValueType && !fieldType.IsPrimitive;
    }

    [LibraryCallback]
    internal static string GetFieldClassName(string className, string fieldName) => Managed.GetFieldOfClass(className, fieldName).FieldType.Name;

    [LibraryCallback]
    internal static bool IsFieldString(string className, string fieldName) => Managed.GetFieldOfClass(className, fieldName).FieldType == typeof (string);

    [LibraryCallback]
    internal static bool IsFieldFloatingPoint(string className, string fieldName)
    {
      FieldInfo fieldOfClass = Managed.GetFieldOfClass(className, fieldName);
      return fieldOfClass.FieldType == typeof (float) || fieldOfClass.FieldType == typeof (double);
    }

    [LibraryCallback]
    internal static bool IsFieldBoolean(string className, string fieldName) => Managed.GetFieldOfClass(className, fieldName).FieldType == typeof (bool);

    [LibraryCallback]
    internal static bool IsFieldEnum(string className, string fieldName) => Managed.GetFieldOfClass(className, fieldName).FieldType.IsEnum;

    [LibraryCallback]
    internal static string GetEnumNamesOfField(string className, string fieldName)
    {
      string typeName = Managed.GetFieldOfClass(className, fieldName).FieldType.FullName;
      string str = typeName.Substring(0, typeName.IndexOf('.'));
      if (str != null && str != "" && str != Assembly.GetExecutingAssembly().GetName().Name)
        typeName = typeName + ", " + str;
      Type type = Type.GetType(typeName);
      if (type == (Type) null)
      {
        int startIndex = typeName.IndexOf(',');
        string name = typeName.Remove(startIndex);
        foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
          type = assembly.GetType(name);
          if (type != (Type) null)
            break;
        }
      }
      type.GetEnumValues();
      return string.Join(" ", type.GetEnumNames());
    }

    [LibraryCallback]
    internal static int GetClassFieldSize(string className, string fieldName)
    {
      Type fieldType = Managed.GetFieldOfClass(className, fieldName).FieldType;
      int num = -1;
      if (fieldType == typeof (byte))
        num = 1;
      else if (fieldType == typeof (sbyte))
        num = 1;
      else if (fieldType == typeof (short))
        num = 2;
      else if (fieldType == typeof (ushort))
        num = 2;
      else if (fieldType == typeof (int))
        num = 4;
      else if (fieldType == typeof (uint))
        num = 4;
      else if (fieldType == typeof (long))
        num = 8;
      else if (fieldType == typeof (ulong))
        num = 8;
      else if (fieldType == typeof (float))
        num = 4;
      else if (fieldType == typeof (double))
        num = 4;
      else if (fieldType == typeof (long))
        num = 4;
      else if (fieldType == typeof (bool))
        num = 1;
      return num;
    }

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    [MonoNativeFunctionWrapper]
    public delegate void PassManagedInitializeMethodPointerDelegate([MarshalAs(UnmanagedType.FunctionPtr)] Delegate initalizer);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    [MonoNativeFunctionWrapper]
    public delegate void PassManagedCallbackMethodPointersDelegate([MarshalAs(UnmanagedType.FunctionPtr)] Delegate methodDelegate);

    [MonoNativeFunctionWrapper]
    public delegate void InitializerDelegate(Delegate argument);

    public enum RglScriptFieldType
    {
      RglSftString,
      RglSftDouble,
      RglSftFloat,
      RglSftBool,
      RglSftInt,
      RglSftVec3,
      RglSftEntity,
      RglSftTexture,
      RglSftMesh,
      RglSftEnum,
      RglSftMaterial,
      RglSftButton,
      RglSftColor,
      RglSftMatrixFrame,
    }
  }
}
