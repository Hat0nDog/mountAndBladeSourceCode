// Decompiled with JetBrains decompiler
// Type: TaleWorlds.Core.GameTextManager
// Assembly: TaleWorlds.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 43F7B45C-9AE1-4715-A37B-2364840F62AF
// Assembly location: E:\SteamLibrary\steamapps\common\Mount & Blade II Bannerlord\bin\Win64_Shipping_Client\TaleWorlds.Core.dll

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.SaveSystem;

namespace TaleWorlds.Core
{
  [SaveableClass(10018)]
  public class GameTextManager
  {
    private readonly Dictionary<string, GameText> _gameTexts;

    internal static void AutoGeneratedStaticCollectObjectsGameTextManager(
      object o,
      List<object> collectedObjects)
    {
      ((GameTextManager) o).AutoGeneratedInstanceCollectObjects(collectedObjects);
    }

    protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
    {
    }

    public GameTextManager() => this._gameTexts = new Dictionary<string, GameText>();

    public GameText GetGameText(string id)
    {
      GameText gameText;
      return this._gameTexts.TryGetValue(id, out gameText) ? gameText : (GameText) null;
    }

    public GameText AddGameText(string id)
    {
      GameText gameText;
      if (!this._gameTexts.TryGetValue(id, out gameText))
      {
        gameText = new GameText(id);
        this._gameTexts.Add(gameText.Id, gameText);
      }
      return gameText;
    }

    public bool TryGetText(string id, string variation, out TextObject text)
    {
      text = (TextObject) null;
      GameText gameText;
      this._gameTexts.TryGetValue(id, out gameText);
      if (gameText != null)
      {
        text = variation != null ? gameText.GetVariation(variation) : gameText.DefaultText;
        if (text != null)
        {
          text = text.CopyTextObject();
          text.AddIDToValue(id);
          return true;
        }
      }
      return false;
    }

    public TextObject FindText(string id, string variation = null)
    {
      TextObject text;
      return this.TryGetText(id, variation, out text) ? text : new TextObject("{=!}ERROR: Text with id " + id + " doesn't exist!");
    }

    public IEnumerable<TextObject> FindAllTextVariations(string id)
    {
      GameText gameText;
      this._gameTexts.TryGetValue(id, out gameText);
      if (gameText != null)
      {
        foreach (GameText.GameTextVariation variation in gameText.Variations)
          yield return variation.Text;
      }
    }

    public void LoadGameTexts(string xmlPath) => this.LoadFromXML(this.LoadXmlFile(xmlPath));

    private XmlDocument LoadXmlFile(string path)
    {
      Debug.Print("opening " + path);
      XmlDocument xmlDocument = new XmlDocument();
      StreamReader streamReader = new StreamReader(path);
      xmlDocument.LoadXml(streamReader.ReadToEnd());
      streamReader.Close();
      return xmlDocument;
    }

    private void LoadFromXML(XmlDocument doc)
    {
      Debug.Print("loading strings.xml:");
      if (doc.ChildNodes.Count <= 1)
        throw new TWXmlLoadException("Incorrect XML document format.");
      if (doc.ChildNodes[1].Name != "base")
        throw new TWXmlLoadException("Incorrect XML document format.");
      if (doc.ChildNodes[1].ChildNodes[0].Name != "strings")
        throw new TWXmlLoadException("Incorrect XML document format.");
      XmlNode xmlNode = (XmlNode) null;
      if (doc.ChildNodes[1].ChildNodes[0].Name == "strings")
        xmlNode = doc.ChildNodes[1].ChildNodes[0].ChildNodes[0];
      for (; xmlNode != null; xmlNode = xmlNode.NextSibling)
      {
        if (xmlNode.Name == "string" && xmlNode.NodeType != XmlNodeType.Comment)
        {
          if (xmlNode.Attributes == null)
            throw new TWXmlLoadException("Node attributes are null.");
          string[] strArray = xmlNode.Attributes["id"].Value.Split('.');
          GameText gameText = this.AddGameText(strArray[0]);
          string variationId = "";
          if (strArray.Length > 1)
            variationId = strArray[1];
          TextObject text = xmlNode.Attributes["sound_path"] == null ? new TextObject(xmlNode.Attributes["text"].Value) : new TextObject(xmlNode.Attributes["text"].Value + "[sp:" + xmlNode.Attributes["sound_path"].Value + "]");
          List<GameTextManager.ChoiceTag> choiceTags = new List<GameTextManager.ChoiceTag>();
          foreach (XmlNode childNode in xmlNode.ChildNodes)
          {
            if (childNode.Name == "tags")
            {
              XmlNodeList childNodes = childNode.ChildNodes;
              for (int i = 0; i < childNodes.Count; ++i)
              {
                XmlAttributeCollection attributes = childNodes[i].Attributes;
                if (attributes != null)
                {
                  int weight = 1;
                  XmlAttribute xmlAttribute = attributes["weight"];
                  GameTextManager.ChoiceTag choiceTag = new GameTextManager.ChoiceTag(attributes["tag_name"].Value, weight);
                  choiceTags.Add(choiceTag);
                }
              }
            }
          }
          gameText.AddVariationWithId(variationId, text, choiceTags);
        }
      }
    }

    public struct ChoiceTag
    {
      public string TagName { get; private set; }

      public uint Weight { get; private set; }

      public bool IsTagReversed { get; private set; }

      public ChoiceTag(string tagName, int weight)
        : this()
      {
        this.TagName = tagName;
        this.Weight = (uint) Math.Abs(weight);
        this.IsTagReversed = weight < 0;
      }
    }
  }
}
