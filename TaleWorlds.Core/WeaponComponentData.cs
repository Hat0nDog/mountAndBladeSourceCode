// Decompiled with JetBrains decompiler
// Type: TaleWorlds.Core.WeaponComponentData
// Assembly: TaleWorlds.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 43F7B45C-9AE1-4715-A37B-2364840F62AF
// Assembly location: E:\SteamLibrary\steamapps\common\Mount & Blade II Bannerlord\bin\Win64_Shipping_Client\TaleWorlds.Core.dll

using System;
using System.Collections.Generic;
using System.Xml;
using TaleWorlds.Library;
using TaleWorlds.SaveSystem;

namespace TaleWorlds.Core
{
  [SaveableClass(10036)]
  public class WeaponComponentData
  {
    public WeaponFlags WeaponFlags;

    internal static void AutoGeneratedStaticCollectObjectsWeaponComponentData(
      object o,
      List<object> collectedObjects)
    {
      ((WeaponComponentData) o).AutoGeneratedInstanceCollectObjects(collectedObjects);
    }

    protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
    {
    }

    public WeaponComponentData.WeaponTiers WeaponTier { get; private set; }

    public string WeaponUsageId { get; private set; }

    public int BodyArmor { get; private set; }

    public string PhysicsMaterial { get; private set; }

    public string FlyingSoundCode { get; private set; }

    public string PassbySoundCode { get; private set; }

    public string ItemUsage { get; private set; }

    public int ThrustSpeed { get; private set; }

    public int SwingSpeed { get; private set; }

    public int MissileSpeed { get; private set; }

    public int WeaponLength { get; private set; }

    public float WeaponBalance { get; private set; }

    public int ThrustDamage { get; private set; }

    public DamageTypes ThrustDamageType { get; private set; }

    public int SwingDamage { get; private set; }

    public DamageTypes SwingDamageType { get; private set; }

    public int Accuracy { get; private set; }

    public WeaponClass WeaponClass { get; private set; }

    public WeaponClass AmmoClass { get; private set; }

    public int MissileDamage => this.ThrustDamage;

    public float Inertia { get; private set; }

    public float CenterOfMass { get; private set; }

    public Vec3 CenterOfMass3D { get; private set; }

    public float SwingDamageFactor { get; private set; }

    public float ThrustDamageFactor { get; private set; }

    public int Handling { get; private set; }

    public float SweetSpotReach { get; private set; }

    public string TrailParticleName { get; private set; }

    public MatrixFrame StickingFrame { get; private set; }

    public Vec3 AmmoOffset { get; private set; }

    public short MaxDataValue { get; private set; }

    public MatrixFrame Frame { get; private set; }

    public Vec3 RotationSpeed { get; private set; }

    public void Init(
      string weaponUsageName,
      string physicsMaterial,
      string itemUsage,
      DamageTypes thrustDamageType,
      DamageTypes swingDamageType,
      int bodyArmor,
      int weaponLength,
      float weaponBalance,
      float inertia,
      float centerOfMass,
      int handling,
      float swingDamageFactor,
      float thrustDamageFactor,
      short maxDataValue,
      string passBySoundCode,
      int accuracy,
      int missileSpeed,
      MatrixFrame stickingFrame,
      WeaponClass ammoClass,
      float sweetSpot,
      int swingSpeed,
      int swingDamage,
      int thrustSpeed,
      int thrustDamage,
      Vec3 rotationSpeed,
      WeaponComponentData.WeaponTiers tier)
    {
      this.WeaponUsageId = weaponUsageName;
      this.PhysicsMaterial = physicsMaterial;
      this.ItemUsage = itemUsage;
      this.ThrustDamageType = thrustDamageType;
      this.SwingDamageType = swingDamageType;
      this.BodyArmor = bodyArmor;
      this.WeaponLength = weaponLength;
      this.WeaponBalance = weaponBalance;
      this.Inertia = inertia;
      this.CenterOfMass = centerOfMass;
      this.Handling = handling;
      this.SwingDamageFactor = swingDamageFactor;
      this.ThrustDamageFactor = thrustDamageFactor;
      this.MaxDataValue = maxDataValue;
      this.PassbySoundCode = passBySoundCode;
      this.Accuracy = accuracy;
      this.MissileSpeed = missileSpeed;
      this.StickingFrame = stickingFrame;
      this.AmmoClass = ammoClass;
      this.SweetSpotReach = sweetSpot;
      this.SwingSpeed = swingSpeed;
      this.SwingDamage = swingDamage;
      this.ThrustSpeed = thrustSpeed;
      this.ThrustDamage = thrustDamage;
      this.Frame = MatrixFrame.Identity;
      this.CenterOfMass3D = new Vec3(z: centerOfMass);
      this.RotationSpeed = rotationSpeed;
      this.WeaponTier = tier;
    }

    public bool IsMeleeWeapon => this.WeaponFlags.HasAllFlags<WeaponFlags>(WeaponFlags.MeleeWeapon);

    public bool IsRangedWeapon => this.WeaponFlags.HasAllFlags<WeaponFlags>(WeaponFlags.RangedWeapon);

    public bool IsPolearm => this.WeaponFlags.HasAllFlags<WeaponFlags>(WeaponFlags.MeleeWeapon | WeaponFlags.WideGrip);

    public bool IsConsumable => this.WeaponFlags.HasAllFlags<WeaponFlags>(WeaponFlags.Consumable);

    public bool IsAmmo => !this.WeaponFlags.HasAnyFlag<WeaponFlags>(WeaponFlags.WeaponMask) && this.IsConsumable;

    public bool IsShield => !this.WeaponFlags.HasAnyFlag<WeaponFlags>(WeaponFlags.WeaponMask) && this.WeaponFlags.HasAllFlags<WeaponFlags>(WeaponFlags.HasHitPoints | WeaponFlags.CanBlockRanged);

    public void SetFrame(MatrixFrame frame) => this.Frame = frame;

    public void SetAmmoOffset(Vec3 ammoOffset) => this.AmmoOffset = ammoOffset;

    public SkillObject RelevantSkill => WeaponComponentData.GetRelevantSkillFromWeaponClass(this.WeaponClass);

    public bool CanHitMultipleTargets => this.WeaponClass == WeaponClass.TwoHandedAxe || this.WeaponClass == WeaponClass.TwoHandedMace;

    public static SkillObject GetRelevantSkillFromWeaponClass(WeaponClass weaponClass)
    {
      SkillObject skillObject = (SkillObject) null;
      switch (weaponClass)
      {
        case WeaponClass.Dagger:
        case WeaponClass.OneHandedSword:
        case WeaponClass.OneHandedAxe:
        case WeaponClass.Mace:
          skillObject = DefaultSkills.OneHanded;
          break;
        case WeaponClass.TwoHandedSword:
        case WeaponClass.TwoHandedAxe:
        case WeaponClass.TwoHandedMace:
          skillObject = DefaultSkills.TwoHanded;
          break;
        case WeaponClass.OneHandedPolearm:
        case WeaponClass.TwoHandedPolearm:
        case WeaponClass.LowGripPolearm:
          skillObject = DefaultSkills.Polearm;
          break;
        case WeaponClass.Arrow:
        case WeaponClass.Bow:
          skillObject = DefaultSkills.Bow;
          break;
        case WeaponClass.Bolt:
        case WeaponClass.Crossbow:
          skillObject = DefaultSkills.Crossbow;
          break;
        case WeaponClass.Stone:
        case WeaponClass.Boulder:
        case WeaponClass.ThrowingAxe:
        case WeaponClass.ThrowingKnife:
        case WeaponClass.Javelin:
          skillObject = DefaultSkills.Throwing;
          break;
        case WeaponClass.SmallShield:
        case WeaponClass.LargeShield:
          skillObject = DefaultSkills.OneHanded;
          break;
      }
      return skillObject;
    }

    public static ItemObject.ItemTypeEnum GetItemTypeFromWeaponClass(
      WeaponClass weaponClass)
    {
      switch (weaponClass)
      {
        case WeaponClass.Undefined:
        case WeaponClass.NumClasses:
          return ItemObject.ItemTypeEnum.Invalid;
        case WeaponClass.Dagger:
        case WeaponClass.OneHandedSword:
        case WeaponClass.OneHandedAxe:
        case WeaponClass.Mace:
          return ItemObject.ItemTypeEnum.OneHandedWeapon;
        case WeaponClass.TwoHandedSword:
        case WeaponClass.TwoHandedAxe:
        case WeaponClass.Pick:
        case WeaponClass.TwoHandedMace:
          return ItemObject.ItemTypeEnum.TwoHandedWeapon;
        case WeaponClass.OneHandedPolearm:
        case WeaponClass.TwoHandedPolearm:
        case WeaponClass.LowGripPolearm:
          return ItemObject.ItemTypeEnum.Polearm;
        case WeaponClass.Arrow:
          return ItemObject.ItemTypeEnum.Arrows;
        case WeaponClass.Bolt:
          return ItemObject.ItemTypeEnum.Bolts;
        case WeaponClass.Cartridge:
          return ItemObject.ItemTypeEnum.Bullets;
        case WeaponClass.Bow:
          return ItemObject.ItemTypeEnum.Bow;
        case WeaponClass.Crossbow:
          return ItemObject.ItemTypeEnum.Crossbow;
        case WeaponClass.Stone:
        case WeaponClass.Boulder:
        case WeaponClass.ThrowingAxe:
        case WeaponClass.ThrowingKnife:
        case WeaponClass.Javelin:
          return ItemObject.ItemTypeEnum.Thrown;
        case WeaponClass.Pistol:
          return ItemObject.ItemTypeEnum.Pistol;
        case WeaponClass.Musket:
          return ItemObject.ItemTypeEnum.Musket;
        case WeaponClass.SmallShield:
        case WeaponClass.LargeShield:
          return ItemObject.ItemTypeEnum.Shield;
        case WeaponClass.Banner:
          return ItemObject.ItemTypeEnum.Banner;
        default:
          return ItemObject.ItemTypeEnum.Invalid;
      }
    }

    public WeaponComponentData(ItemObject item, WeaponClass weaponClass = WeaponClass.Undefined, WeaponFlags weaponFlags = (WeaponFlags) 0)
    {
      this.BodyArmor = 0;
      this.PhysicsMaterial = "";
      this.FlyingSoundCode = "";
      this.PassbySoundCode = "";
      this.ItemUsage = (string) null;
      this.SwingSpeed = 0;
      this.ThrustSpeed = 0;
      this.MissileSpeed = 0;
      this.WeaponLength = 0;
      this.ThrustDamage = 0;
      this.SwingDamage = 0;
      this.AmmoOffset = Vec3.Zero;
      this.Accuracy = 0;
      this.StickingFrame = MatrixFrame.Identity;
      this.TrailParticleName = "";
      this.WeaponClass = weaponClass;
      this.WeaponFlags = weaponFlags;
      this.Frame = MatrixFrame.Identity;
      this.RotationSpeed = Vec3.Zero;
    }

    public void Deserialize(ItemObject item, XmlNode node)
    {
      this.BodyArmor = node.Attributes["body_armor"] != null ? int.Parse(node.Attributes["body_armor"].Value) : 0;
      this.PhysicsMaterial = node.Attributes["physics_material"]?.Value;
      this.FlyingSoundCode = node.Attributes["flying_sound_code"]?.Value;
      this.PassbySoundCode = node.Attributes["passby_sound_code"]?.Value;
      this.ItemUsage = node.Attributes["item_usage"]?.Value;
      this.WeaponBalance = node.Attributes["weapon_balance"] != null ? (float) int.Parse(node.Attributes["weapon_balance"].Value) * 0.01f : 0.0f;
      this.SwingSpeed = node.Attributes["speed_rating"] != null ? int.Parse(node.Attributes["speed_rating"].Value) : 0;
      this.ThrustSpeed = node.Attributes["thrust_speed"] != null ? int.Parse(node.Attributes["thrust_speed"].Value) : 0;
      this.MissileSpeed = node.Attributes["missile_speed"] != null ? int.Parse(node.Attributes["missile_speed"].Value) : 0;
      this.WeaponLength = node.Attributes["weapon_length"] != null ? int.Parse(node.Attributes["weapon_length"].Value) : 0;
      this.ThrustDamage = node.Attributes["thrust_damage"] != null ? int.Parse(node.Attributes["thrust_damage"].Value) : 0;
      this.SwingDamage = node.Attributes["swing_damage"] != null ? int.Parse(node.Attributes["swing_damage"].Value) : 0;
      this.Accuracy = node.Attributes["accuracy"] != null ? int.Parse(node.Attributes["accuracy"].Value) : 100;
      this.ThrustDamageType = node.Attributes["thrust_damage_type"] != null ? (DamageTypes) Enum.Parse(typeof (DamageTypes), node.Attributes["thrust_damage_type"].Value) : DamageTypes.Blunt;
      this.SwingDamageType = node.Attributes["swing_damage_type"] != null ? (DamageTypes) Enum.Parse(typeof (DamageTypes), node.Attributes["swing_damage_type"].Value) : DamageTypes.Blunt;
      this.WeaponClass = node.Attributes["weapon_class"] != null ? (WeaponClass) Enum.Parse(typeof (WeaponClass), node.Attributes["weapon_class"].Value) : WeaponClass.Undefined;
      this.AmmoClass = node.Attributes["ammo_class"] != null ? (WeaponClass) Enum.Parse(typeof (WeaponClass), node.Attributes["ammo_class"].Value) : WeaponClass.Undefined;
      this.CenterOfMass = (float) ((double) this.WeaponLength * 0.5 * 0.00999999977648258);
      this.CenterOfMass3D = node.Attributes["center_of_mass"] != null ? Vec3.Parse(node.Attributes["center_of_mass"].Value) : Vec3.Zero;
      if (this.WeaponClass != WeaponClass.Bow && this.WeaponClass != WeaponClass.Crossbow && (this.WeaponClass != WeaponClass.SmallShield && this.WeaponClass != WeaponClass.LargeShield) && (this.WeaponClass != WeaponClass.Arrow && this.WeaponClass != WeaponClass.Bolt && (this.WeaponClass != WeaponClass.ThrowingKnife && this.WeaponClass != WeaponClass.ThrowingAxe)) && (this.WeaponClass != WeaponClass.Javelin && this.WeaponClass != WeaponClass.Stone))
      {
        int weaponClass = (int) this.WeaponClass;
      }
      XmlAttribute attribute1 = node.Attributes["ammo_limit"];
      XmlAttribute attribute2 = node.Attributes["stack_amount"];
      XmlAttribute attribute3 = node.Attributes["hit_points"];
      this.MaxDataValue = attribute1 == null ? (attribute2 == null ? (attribute3 == null ? (short) 0 : short.Parse(attribute3.Value)) : short.Parse(attribute2.Value)) : short.Parse(attribute1.Value);
      Vec3 vec3 = new Vec3();
      Mat3 identity1 = Mat3.Identity;
      XmlNode attribute4 = (XmlNode) node.Attributes["sticking_position"];
      if (attribute4 != null)
      {
        string[] strArray = attribute4.Value.Split(',');
        if (strArray.Length == 3)
        {
          float.TryParse(strArray[0], out vec3.x);
          float.TryParse(strArray[1], out vec3.y);
          float.TryParse(strArray[2], out vec3.z);
        }
      }
      XmlNode attribute5 = (XmlNode) node.Attributes["sticking_rotation"];
      if (attribute5 != null)
      {
        string[] strArray = attribute5.Value.Split(',');
        if (strArray.Length == 3)
        {
          float result1;
          float.TryParse(strArray[0], out result1);
          float result2;
          float.TryParse(strArray[1], out result2);
          float result3;
          float.TryParse(strArray[2], out result3);
          identity1.RotateAboutSide(result1.ToRadians());
          identity1.RotateAboutUp(result2.ToRadians());
          identity1.RotateAboutForward(result3.ToRadians());
        }
      }
      vec3 = identity1.TransformToParent(vec3);
      this.StickingFrame = new MatrixFrame(identity1, vec3);
      Vec3 o = new Vec3();
      Mat3 identity2 = Mat3.Identity;
      XmlNode attribute6 = (XmlNode) node.Attributes["position"];
      if (attribute6 != null)
      {
        string[] strArray = attribute6.Value.Split(',');
        if (strArray.Length == 3)
        {
          float.TryParse(strArray[0], out o.x);
          float.TryParse(strArray[1], out o.y);
          float.TryParse(strArray[2], out o.z);
        }
      }
      XmlNode attribute7 = (XmlNode) node.Attributes["rotation"];
      if (attribute7 != null)
      {
        string[] strArray = attribute7.Value.Split(',');
        if (strArray.Length == 3)
        {
          float result1;
          float.TryParse(strArray[0], out result1);
          float result2;
          float.TryParse(strArray[1], out result2);
          float result3;
          float.TryParse(strArray[2], out result3);
          identity2.RotateAboutUp(result3.ToRadians());
          identity2.RotateAboutSide(result1.ToRadians());
          identity2.RotateAboutForward(result2.ToRadians());
        }
      }
      this.Frame = new MatrixFrame(identity2, o);
      this.RotationSpeed = node.Attributes["rotation_speed"] != null ? Vec3.Parse(node.Attributes["rotation_speed"].Value) : Vec3.Zero;
      this.TrailParticleName = node.Attributes["trail_particle_name"]?.Value;
      foreach (XmlNode childNode in node.ChildNodes)
      {
        if (childNode.Name == "WeaponFlags")
        {
          foreach (WeaponFlags weaponFlags in Enum.GetValues(typeof (WeaponFlags)))
          {
            if (childNode.Attributes[weaponFlags.ToString()] != null)
              this.WeaponFlags |= weaponFlags;
          }
        }
      }
      this.Inertia = item.Weight * 0.05f;
      this.Handling = this.ThrustSpeed;
      this.SweetSpotReach = 0.93f;
      this.SetDamageFactors(item.Weight);
    }

    private void SetDamageFactors(float weight)
    {
      DamageTypes swingDamageType = this.SwingDamageType;
      if (this.WeaponClass == WeaponClass.Bow || this.WeaponClass == WeaponClass.Crossbow || (this.WeaponClass == WeaponClass.ThrowingAxe || this.WeaponClass == WeaponClass.ThrowingKnife) || (this.WeaponClass == WeaponClass.Javelin || this.WeaponClass == WeaponClass.Arrow || this.WeaponClass == WeaponClass.Bolt))
      {
        this.SwingDamageFactor = 1f;
        this.ThrustDamageFactor = 1f;
      }
      else
      {
        float num1 = (float) Math.Sqrt(Math.Sqrt((double) weight / ((double) this.WeaponLength * 0.00999999977648258)));
        float num2 = 0.0f;
        switch (swingDamageType)
        {
          case DamageTypes.Cut:
            num1 *= 0.8f;
            num2 = 0.5f;
            break;
          case DamageTypes.Pierce:
            num1 *= 0.7f;
            num2 = 0.4f;
            break;
          case DamageTypes.Blunt:
            num1 *= 1f;
            num2 = 1f;
            break;
        }
        float num3 = num1 * 0.8f;
        float num4 = num2 * 0.8f;
        this.SwingDamageFactor = num4;
        this.ThrustDamageFactor = num4;
      }
    }

    public float GetRealWeaponLength() => (float) this.WeaponLength * 0.01f + Vec3.DotProduct(this.Frame.rotation.u, this.Frame.origin);

    public MatrixFrame GetMissileStartingFrame()
    {
      MatrixFrame identity;
      if (this.WeaponClass == WeaponClass.Arrow || this.WeaponClass == WeaponClass.Bolt)
      {
        Mat3 mat3 = new Mat3(1f, 0.0f, 0.0f, 0.0f, 0.0f, -1f, 0.0f, 1f, 0.0f);
        identity.rotation = mat3;
        identity.origin = Vec3.Zero;
      }
      else
      {
        identity = MatrixFrame.Identity;
        if (this.WeaponClass == WeaponClass.ThrowingAxe)
          identity.rotation.RotateAboutUp(-1.570796f);
        else if (this.WeaponClass == WeaponClass.ThrowingKnife)
        {
          identity.rotation.RotateAboutUp(-1.570796f);
        }
        else
        {
          Mat3 mat3 = new Mat3(1f, 0.0f, 0.0f, 0.0f, 0.0f, -1f, 0.0f, 1f, 0.0f);
          identity.rotation = mat3;
        }
      }
      return identity;
    }

    public enum WeaponTiers
    {
      Tier1,
      Tier2,
      Tier3,
      Tier4,
      Special,
    }
  }
}
