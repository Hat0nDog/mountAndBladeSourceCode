// Decompiled with JetBrains decompiler
// Type: TaleWorlds.Core.CraftingTemplate
// Assembly: TaleWorlds.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 43F7B45C-9AE1-4715-A37B-2364840F62AF
// Assembly location: E:\SteamLibrary\steamapps\common\Mount & Blade II Bannerlord\bin\Win64_Shipping_Client\TaleWorlds.Core.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.ObjectSystem;
using TaleWorlds.SaveSystem;

namespace TaleWorlds.Core
{
  [SaveableClass(10040)]
  public class CraftingTemplate : MBObjectBase
  {
    public TextObject TemplateName;
    private PieceData[] _buildOrders;
    private WeaponUsageData[] _weaponUsageDatas;
    private bool[] _hiddenPieceTypesOnHolsteredMesh;
    private float[][] _statDataValues;
    private List<CraftingPiece> _craftingPieces;

    internal static void AutoGeneratedStaticCollectObjectsCraftingTemplate(
      object o,
      List<object> collectedObjects)
    {
      ((MBObjectBase) o).AutoGeneratedInstanceCollectObjects(collectedObjects);
    }

    protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects) => base.AutoGeneratedInstanceCollectObjects(collectedObjects);

    public IEnumerable<PieceData> BuildOrders => (IEnumerable<PieceData>) this._buildOrders;

    public IEnumerable<WeaponUsageData> WeaponUsageDatas => (IEnumerable<WeaponUsageData>) this._weaponUsageDatas;

    public ItemModifierGroup ItemModifierGroup { get; private set; }

    public string[] ItemHolsters { get; private set; }

    public Vec3 ItemHolsterPositionShift { get; private set; }

    public bool UseWeaponAsHolsterMesh { get; private set; }

    public bool AlwaysShowHolsterWithWeapon { get; private set; }

    public bool RotateWeaponInHolster { get; private set; }

    public CraftingPiece.PieceTypes PieceTypeToScaleHolsterWith { get; private set; }

    public int GetIndexOfUsageDataWithId(string weaponUsageDataId)
    {
      int num = -1;
      for (int index = 0; index < this._weaponUsageDatas.Length; ++index)
      {
        if (weaponUsageDataId == this._weaponUsageDatas[index].WeaponUsageDataId)
        {
          num = index;
          break;
        }
      }
      return num;
    }

    public bool IsPieceTypeHiddenOnHolster(CraftingPiece.PieceTypes pieceType) => this._hiddenPieceTypesOnHolsteredMesh[(int) pieceType];

    public IEnumerable<KeyValuePair<CraftingTemplate.CraftingStatTypes, float>> GetStatDatas(
      int usageIndex,
      DamageTypes thrustDamageType,
      DamageTypes swingDamageType)
    {
      for (int i = 0; i < this._statDataValues[usageIndex].Length; ++i)
      {
        CraftingTemplate.CraftingStatTypes key = (CraftingTemplate.CraftingStatTypes) i;
        bool flag = false;
        switch (key)
        {
          case CraftingTemplate.CraftingStatTypes.ThrustSpeed:
          case CraftingTemplate.CraftingStatTypes.ThrustDamage:
            flag = thrustDamageType == DamageTypes.Invalid;
            break;
          case CraftingTemplate.CraftingStatTypes.SwingSpeed:
          case CraftingTemplate.CraftingStatTypes.SwingDamage:
            flag = swingDamageType == DamageTypes.Invalid;
            break;
        }
        if (!flag && (double) this._statDataValues[usageIndex][i] >= 0.0)
          yield return new KeyValuePair<CraftingTemplate.CraftingStatTypes, float>(key, this._statDataValues[usageIndex][i]);
      }
    }

    public override string ToString() => this.TemplateName.ToString();

    public bool IsPieceTypeUsable(CraftingPiece.PieceTypes pieceType) => this.BuildOrders.Any<PieceData>((Func<PieceData, bool>) (bO => bO.PieceType == pieceType));

    public override void Deserialize(MBObjectManager objectManager, XmlNode node)
    {
      base.Deserialize(objectManager, node);
      this._hiddenPieceTypesOnHolsteredMesh = new bool[4];
      string objectName = node.Attributes["item_modifier_group"] != null ? node.Attributes["item_modifier_group"].Value : (string) null;
      if (objectName != null)
        this.ItemModifierGroup = Game.Current.ObjectManager.GetObject<ItemModifierGroup>(objectName);
      this.ItemHolsters = node.Attributes["item_holsters"].Value.Split(':');
      this.ItemHolsterPositionShift = Vec3.Parse(node.Attributes["default_item_holster_position_offset"].Value);
      this.UseWeaponAsHolsterMesh = XmlHelper.ReadBool(node, "use_weapon_as_holster_mesh");
      this.AlwaysShowHolsterWithWeapon = XmlHelper.ReadBool(node, "always_show_holster_with_weapon");
      this.RotateWeaponInHolster = XmlHelper.ReadBool(node, "rotate_weapon_in_holster");
      XmlAttribute attribute1 = node.Attributes["piece_type_to_scale_holster_with"];
      this.PieceTypeToScaleHolsterWith = attribute1 != null ? (CraftingPiece.PieceTypes) Enum.Parse(typeof (CraftingPiece.PieceTypes), attribute1.Value) : CraftingPiece.PieceTypes.Invalid;
      XmlAttribute attribute2 = node.Attributes["hidden_piece_types_on_holster"];
      if (attribute2 != null)
      {
        string str1 = attribute2.Value;
        char[] chArray = new char[1]{ ',' };
        foreach (string str2 in str1.Split(chArray))
          this._hiddenPieceTypesOnHolsteredMesh[(int) Enum.Parse(typeof (CraftingPiece.PieceTypes), str2)] = true;
      }
      foreach (XmlNode childNode1 in node.ChildNodes)
      {
        if (childNode1.Attributes != null)
        {
          string name = childNode1.Name;
          if (!(name == "PieceDatas"))
          {
            if (!(name == "WeaponUsageDatas"))
            {
              if (!(name == "UsablePieces"))
              {
                if (name == "StatsData")
                {
                  XmlAttribute attribute3 = childNode1.Attributes["usage_data"];
                  float[] numArray = new float[10];
                  for (int index = 0; index < numArray.Length; ++index)
                    numArray[index] = float.MinValue;
                  foreach (XmlNode childNode2 in childNode1.ChildNodes)
                  {
                    if (childNode2.NodeType == XmlNodeType.Element)
                    {
                      XmlAttribute attribute4 = childNode2.Attributes["stat_type"];
                      XmlAttribute attribute5 = childNode2.Attributes["max_value"];
                      CraftingTemplate.CraftingStatTypes craftingStatTypes = (CraftingTemplate.CraftingStatTypes) Enum.Parse(typeof (CraftingTemplate.CraftingStatTypes), attribute4.Value);
                      float num = float.Parse(attribute5.Value);
                      numArray[(int) craftingStatTypes] = num;
                    }
                  }
                  if (attribute3 != null)
                  {
                    this._statDataValues[this.GetIndexOfUsageDataWithId(attribute3.Value)] = numArray;
                  }
                  else
                  {
                    for (int index = 0; index < this._statDataValues.Length; ++index)
                      this._statDataValues[index] = numArray;
                  }
                }
              }
              else
              {
                this._craftingPieces = new List<CraftingPiece>();
                foreach (XmlNode childNode2 in childNode1.ChildNodes)
                {
                  CraftingPiece craftingPiece = MBObjectManager.Instance.GetObject<CraftingPiece>(childNode2.Attributes["piece_id"].Value);
                  if (craftingPiece != null)
                    this._craftingPieces.Add(craftingPiece);
                }
              }
            }
            else
            {
              List<WeaponUsageData> weaponUsageDataList = new List<WeaponUsageData>();
              foreach (XmlNode childNode2 in childNode1.ChildNodes)
              {
                string id = childNode2.Attributes["id"].Value;
                weaponUsageDataList.Add(WeaponUsageDataManager.All.First<WeaponUsageData>((Func<WeaponUsageData, bool>) (wud => wud.WeaponUsageDataId == id)));
              }
              this._weaponUsageDatas = weaponUsageDataList.ToArray();
              this._statDataValues = new float[this._weaponUsageDatas.Length][];
            }
          }
          else
          {
            List<PieceData> pieceDataList = new List<PieceData>();
            foreach (XmlNode childNode2 in childNode1.ChildNodes)
            {
              XmlAttribute attribute3 = childNode2.Attributes["piece_type"];
              XmlAttribute attribute4 = childNode2.Attributes["build_order"];
              CraftingPiece.PieceTypes pieceType = (CraftingPiece.PieceTypes) Enum.Parse(typeof (CraftingPiece.PieceTypes), attribute3.Value);
              int order = int.Parse(attribute4.Value);
              pieceDataList.Add(new PieceData(pieceType, order));
            }
            this._buildOrders = pieceDataList.ToArray();
          }
        }
      }
      this.TemplateName = GameTexts.FindText("str_crafting_template", this.StringId);
    }

    public static MBReadOnlyList<CraftingTemplate> All => MBObjectManager.Instance.GetObjectTypeList<CraftingTemplate>();

    public static CraftingTemplate GetTemplateFromId(string templateId) => MBObjectManager.Instance.GetObject<CraftingTemplate>(templateId);

    public IEnumerable<CraftingPiece> Pieces => (IEnumerable<CraftingPiece>) this._craftingPieces;

    public enum CraftingStatTypes
    {
      Weight,
      WeaponReach,
      ThrustSpeed,
      SwingSpeed,
      ThrustDamage,
      SwingDamage,
      Handling,
      MissileDamage,
      MissileSpeed,
      Accuracy,
      NumStatTypes,
    }
  }
}
