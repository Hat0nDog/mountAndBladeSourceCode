// Decompiled with JetBrains decompiler
// Type: TaleWorlds.Core.EntitySystem`1
// Assembly: TaleWorlds.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 43F7B45C-9AE1-4715-A37B-2364840F62AF
// Assembly location: E:\SteamLibrary\steamapps\common\Mount & Blade II Bannerlord\bin\Win64_Shipping_Client\TaleWorlds.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using TaleWorlds.SaveSystem;

namespace TaleWorlds.Core
{
  [SaveableClass(10007)]
  public class EntitySystem<T> where T : class, IEntityComponent
  {
    private readonly List<T> _components;
    private readonly Dictionary<Type, IList> _componentsOfTypes;

    protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
    {
    }

    public EntitySystem()
    {
      this._components = new List<T>();
      this._componentsOfTypes = new Dictionary<Type, IList>();
    }

    public TComponent AddComponent<TComponent>() where TComponent : class, T, new() => (object) this.AddComponent(typeof (TComponent)) as TComponent;

    public T AddComponent(Type componentType)
    {
      T obj = componentType.GetConstructor(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, (Binder) null, new Type[0], (ParameterModifier[]) null).Invoke(new object[0]) as T;
      this._components.Add(obj);
      for (Type key = obj.GetType(); key != (Type) null && key != typeof (object); key = key.BaseType)
      {
        if (!this._componentsOfTypes.ContainsKey(key))
        {
          IList instance = Activator.CreateInstance(typeof (List<>).MakeGenericType(key)) as IList;
          this._componentsOfTypes.Add(key, instance);
        }
        this._componentsOfTypes[key].Add((object) obj);
      }
      obj.OnInitialize();
      return obj;
    }

    public TComponent GetComponent<TComponent>() where TComponent : class, T
    {
      if (this._componentsOfTypes.ContainsKey(typeof (TComponent)))
      {
        IList componentsOfType = this._componentsOfTypes[typeof (TComponent)];
        if (componentsOfType.Count > 0)
          return componentsOfType[0] as TComponent;
      }
      return default (TComponent);
    }

    public T GetComponent(Type componentType)
    {
      if (this._componentsOfTypes.ContainsKey(componentType))
      {
        IList componentsOfType = this._componentsOfTypes[componentType];
        if (componentsOfType.Count > 0)
          return componentsOfType[0] as T;
      }
      return default (T);
    }

    public List<TComponent> GetComponents<TComponent>() where TComponent : class, T
    {
      if (this._componentsOfTypes.ContainsKey(typeof (TComponent)))
      {
        IList componentsOfType = this._componentsOfTypes[typeof (TComponent)];
        if (componentsOfType.Count > 0)
          return componentsOfType as List<TComponent>;
      }
      return (List<TComponent>) null;
    }

    public List<T> GetComponents() => this._components;

    public void RemoveComponent(T component)
    {
      component.OnFinalize();
      this._components.Remove(component);
      for (Type key = component.GetType(); key != (Type) null && key != typeof (object); key = key.BaseType)
        this._componentsOfTypes[key].Remove((object) component);
    }

    public void RemoveComponent<TComponent>() where TComponent : class, T
    {
      TComponent component = this.GetComponent<TComponent>();
      if ((object) component == null)
        return;
      this.RemoveComponent((T) component);
    }

    public IList<T> Components => (IList<T>) this._components.AsReadOnly();
  }
}
